---
title: "Reproducible Research - Peer Assessment2"
author: "robertwcw"
date: "9/21/2020"
output: 
  html_document: 
    keep_md: yes
    fig_width: 13
    fig_height: 9
    toc_depth: 4
---
## SYNOPSIS

Natural disaster triggered by storms and abnormal weather phenomenons may lead to public health issues and dire economic consequences. The extent, severity, and impact of injuries/fatalities and economic losses are largely determined by the amount of energy unleashed by the types of events in the weather related disasters. This data analysis attempts to address the concerns **WHERE** the events took place and **WHEN** the disasters struck by **WHAT** types of events give rise to deleterious social impact aftermath with respect to economic and public health. Base on the US National Oceanic and Atmospheric Administration (NOAA) storm database, this project makes use of relevant metrics of the number of human injuries/fatalities, financial losses in properties/crops damages in relation to events types across the US from year 1950 to year 2011.  
&nbsp;

#### Initialize R workspace for current session.
```{r setup, results="hide"}
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(TZ = "UTC")      # set global TZ to UTC for POSIXt class

# .Rfliburl <- "https://raw.githubusercontent.com/robertwcw/Rflib/master"
# source(file.path(.Rfliburl,"getRflib.R"),local = TRUE)
# source(getRflib("is.defined.R"),local = TRUE)
# source(getRflib("myplclust.R"),local = TRUE)
# source(getRflib("strCap.R"),local = TRUE)

if (!requireNamespace("data.table",quietly = TRUE)) install.packages("data.table")
library(data.table)
 
if (!requireNamespace("dplyr",quietly = TRUE)) install.packages("dplyr")
library(dplyr, warn.conflicts = FALSE)

if (!requireNamespace("lubridate",quietly = TRUE)) install.packages("lubridate")
library(lubridate, quietly = TRUE, warn.conflicts = FALSE)

if (!requireNamespace("maps",quietly = TRUE)) install.packages("maps")
library(maps)

if (!requireNamespace("lattice", quietly  = TRUE)) install.packages("lattice")
library(lattice)

if (!requireNamespace("scales", quietly  = TRUE)) install.packages("scales")
library(scales)

# 'udf.num2gcs' user-defined function to convert LATITUDE & LONGITUDE coordinate values in integer type to nnn.dddd geographic coordinate system format 
udf.num2gcs <- function(X, y) { # y is number of significant digits.
        if (is.na(X) | is.null(X) | !is.numeric(X)) return(X)
        x <- as.character(X)
        l <- nchar(x)
        ifelse(l < 3, y <- l,
               ifelse(l == 3, y <- 1,
                      ifelse(l == 4, y <- 2,
                             ifelse(l > 4, y <- y, y <- 0))))
        y <- l - y
        X <- as.numeric(paste0(x,"e",-y))
        X
}

# 'udf.stripsign' user-defined function to strip -ve sign from numeric value
udf.stripsign <- function(x) {
        if (!is.na(x) & !is.null(x) & is.numeric(x)) {
                x <- x * sign(x)
        }
        x
}

# 'udf.prependsign' user-defined function to prepend -ve sign to numeric value
udf.prependsign <- function(x) {
        if (!is.na(x) & !is.null(x) & is.numeric(x)) {
                x <- x * sign(-x)
        }
        x
}

# 'udf.str2time' user-defined function to put TIME string into proper format
udf.str2time <- function(x) {
        l <- nchar(x)
        if (l %in% c(3,4)) {
                z <- substr(strptime(sprintf("%04s", x), "%H%M"), 12, 19)
                ifelse(is.na(z) | z == "",
                       x <- "00:00:00",
                       x <- substr(strptime(sprintf("%04s", x), "%H%M"), 12, 19))
        } else
        if (l == 11) {
                z <- substr(strptime(x, "%I:%M:%S %p"), 12, 19)
                ifelse(is.na(z),
                       x <- substr(strptime(x, "%H:%M:%S"), 12, 19),
                       ifelse(z == "",
                              x <- substr(strptime(x, "%H:%M:%S %p"), 12, 19),
                              x <- z))
        }
        x
}

# 'udf.expont' user-defined function for converting number scale character to proper scientific notation.
udf.expont <- function(x, y) {
        x <- ifelse(x %in% c("1","2","3","4","5","6","7","8","9"), paste0("e+0",x),
                    ifelse(x == "H", "e+02",
                           ifelse(x == "K", "e+03",
                                  ifelse(x == "M", "e+06",
                                         ifelse(x == "B", "e+09", "e+0")))))
        as.numeric(paste0(as.character(y),x))
}

# list of states of the USA (exclude off-shore affiliated territories).
mystates <- c(unique(state.fips$abb), "AK", "HI") 

# set up colour palette.
set.seed(2)
i <- sample.int(502, 256)
i <- sample(i, 66)
mypal <- colors(TRUE)[i]

# snapshot of default graphic parameters.
par.def <- par(no.readonly = TRUE) 

```
&nbsp;

#### Data Loading

Loading *raw* comma-delimited text file data set downloaded from course website into R workspace as data.table class object with naming of the data object derives from the source file programmatically.

```{r data.load, cache=TRUE, tidy=TRUE}
# loading data downloaded from course website into R workspace 
#   user  system elapsed 
# 53.457   1.190  57.097 

# set data source url to course website
fileurl <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
datadir <- paste(".", "data", sep = "/")
filetmp <- tempfile()
filenam <- character()

download.file(fileurl, filetmp)

if (!dir.exists(datadir)) {
        dir.create(datadir)
}

# extract source data file name as name of work data object in workspace 
filels <- strsplit(basename(fileurl), "%2F", fixed = TRUE)[[1]]
for (i in 1:length(filels)) 
        {
        filein <- strsplit(filels[i], ".", fixed = TRUE)[[1]]
        if (length(filein) > 1) 
                {
                filenam[i] <- filein[1]
                filesrc <- bzfile(filetmp, open = "r")
                assign(filenam[i], data.table(read.csv(filesrc)))
                flush(filesrc)
                }
        }
close(filesrc)

filenam <- filenam[which(!is.na(filenam))]

unlink(filetmp)
rm(fileurl,filetmp,filesrc,filels,filein)

```
&nbsp;

#### Exploratory Data Analysis

```{r eda.0}
for (i in 1:length(filenam)) {
        print(paste(i, ":",filenam[i], "(",floor(object.size(get(filenam[i]))/10e+05),"MB)"))
}

```
**`r length(filenam)`** *raw* data `r ifelse(length(filenam) > 1, "sets were", "set was")` loaded into R workspace from NOAA sourced data downloaded from the course website. (number in bracket depicts memory footprint).

Structure of data object **`r filenam[1]`**.
```{r eda.1}
str(get(filenam[1]))

```
There are **`r length(names(get(filenam[1])))`** columns found in the *raw* data set **`r filenam[1]`**. 

```{r data.proc, cache=TRUE, tidy=TRUE}
# preprocessing data, perform required transformation for downstream analytic
#    user  system elapsed 
# 333.129  92.214 422.774

d1 <- sub(" .*", "", StormData$BGN_DATE)
d2 <- gsub("[oO]", "0", StormData$BGN_TIME) # rectify typo error of 'O' for '0'
d2 <- sub("12:00:00 AM", "00:00:00", d2) # rectify non-POSIXt compliant time fmt
d2 <- sub("00:00:00 AM", "00:00:00", d2) # rectify non-POSIXt compliant time fmt
d2 <- unlist(lapply(d2, udf.str2time)) # unify various time format to "hh:mm:ss"
StormData <- StormData %>% mutate(EV_TIMESTAMP = as.POSIXct(strptime(paste(d1,d2), "%m/%d/%Y %H:%M:%S")))

rm(d1, d2)

# # # NOT USED
# # prepend -ve sign to LONGITUDE values belong to the western hemisphere
#   StormData$LONGITUDE <- sapply(StormData$LONGITUDE, udf.prependsign)

#   user  system elapsed 
# 36.600   0.271  36.910
# reformat LATITUDE vector to geographic coordinate system format nnn.ddd
  numsign <- sign(StormData$LATITUDE)
  lat <- sapply(StormData$LATITUDE, udf.stripsign)
  lat <- sapply(lat, udf.num2gcs, 2) # '2' is number of significant digits
  StormData$LATITUDE <- lat * (numsign * numsign) # LATs belong to northern hemisphere 

#   user  system elapsed 
# 36.108   0.214  36.344   
# reformat LONGITUDE vector to geographic coordinate system format nnn.ddd
  numsign <- sign(StormData$LONGITUDE)
  lon <- sapply(StormData$LONGITUDE, udf.stripsign)
  lon <- sapply(lon, udf.num2gcs, 3) # '3' is number of significant digits
  StormData$LONGITUDE <- lon * (numsign * -numsign) # LONs belong to western hemisphere
  
rm(lon, lat, numsign)  

# trim whitespaces on both ends of EVTYPE and transform to uppercase
StormData$EVTYPE <- toupper(trimws(StormData$EVTYPE))

# trim redundant intermediate whitespaces of length(n) to length(1)
repeat {
        StormData$EVTYPE <- sub("  ", " ", StormData$EVTYPE, useBytes = TRUE)
        if (length(grep("  ", StormData$EVTYPE, useBytes = TRUE)) == 0) {break}
}

StormData$STATE <- toupper(trimws(StormData$STATE))
StormData$PROPDMGEXP <- toupper(trimws(StormData$PROPDMGEXP))
StormData$CROPDMGEXP <- toupper(trimws(StormData$CROPDMGEXP))

# weather events classes  https://www.weather.gov/iwx/events

# Add a NEW column EVCLASS to StormData data set
StormData <- StormData %>% mutate(EVCLASS = character(1))

# weather event classification coding
# A - TORNADOs of all kinds 
# B - EXTREME TEMPERATURES on both end of the scale
# C - SNOWY & ICY conditions
# D - HIGH WINDS & STORM
# E - RAIN & FLOOD
# F - HAILing condition
# G - CLOUD condition that may lead to storm or tornado event
# H - FIRE 
# I - LIGHTNING
# X - EXCLUDED list - weather events to be excluded from processing
# Z - OTHER events not classified 

# Array Index 24, 25 & 26 of the ev.class array are the special designated classes.
# DO NOT ALTER the hard-designated values in index 24, 25 & 26, except the EXCLUSION keyword for weather events at index [24,2].
# Array Index 24 - EXCLUSION class, use for assigning weather events that are to be excluded from analytic processing. Change the search keyword of the weather event in the character string at index[24,2] as require.
# Array Index 25 - reserved.
# Array Index 26 - OTHER class, use for classifying weather events not classified by the regular class codes from index 1 to 23, and 25. Do NOT alter.
# DO NOT assign empty string value to the array cells, otherwise will result in unexpected outcome.
# DO NOT ALTER the sequence order of the default class codes and search keywords (array index 1 ~ 23).
ev.class <- array(dim = c(26,3))
ev.class[1,1] <- "A"        # CLASS CODE
ev.class[1,2] <- "TORNADO"  # CLASS LABEL
ev.class[1,3] <- "TORNADO"  # SEARCH KEYWORD
ev.class[2,1] <- "B"
ev.class[2,2] <- "EXTREME.TEMP"
ev.class[2,3] <- "HEAT|HOT|DRY|DROUGHT|COLD|CHILL|FROST|TEMP"
ev.class[3,1] <- "C"
ev.class[3,2] <- "SNOW.ICE"
ev.class[3,3] <- "SNOW|ICE|WINTER|BLIZZARD|FREEZ(E|ING)|SLEET|ICY"
ev.class[4,1] <- "D"
ev.class[4,2] <- "WIND.STORM"
ev.class[4,3] <- "WIND|STORM|GUSTNA|HURRICAN|TYPHOON|TURBULENCE|BURST|DUST|TSTM|CLOUD|FUNNEL|WALL"
ev.class[5,1] <- "E"
ev.class[5,2] <- "RAIN.FLOOD"
ev.class[5,3] <- "FLOOD|WET|RAIN|SHOWER|HEAVY|PRECIPITAT"
ev.class[6,1] <- "F"
ev.class[6,2] <- "HAIL"
ev.class[6,3] <- "HAIL"
# ev.class[7,1] <- "G"
# ev.class[7,2] <- "CLOUD"
# ev.class[7,3] <- "CLOUD|FUNNEL|WALL"
ev.class[8,1] <- "H"
ev.class[8,2] <- "WILD.FIRE"
ev.class[8,3] <- "FIRE"
ev.class[11,1] <- "I"
ev.class[11,2] <- "LIGHTNING"
ev.class[11,3] <- "LIGHTNING"
ev.class[24,1] <- "X"         # EXCLUSION class. Hard-designated. DO NOT ALTER.
ev.class[24,2] <- "EXCLUDED"  # class label. Hard-designated. DO NOT ALTER.
ev.class[24,3] <- "SUMMARY"   # EXCLUSION keyword, change as necessary.
ev.class[26,1] <- "Z"         # Hard-designated. DO NOT ALTER.
ev.class[26,2] <- "OTHERS"    # class label. Hard-designated. DO NOT ALTER.
ev.class[26,3] <- "OTHERS"    # OTHER class. DO NOT ALTER.

P <- which(!is.na(ev.class[1:23,1]))
N <- length(P)

# 0. EXCLUDED - weather events to exclude
evclass.rowid <- grep(ev.class[24,3], StormData$EVTYPE)
evclass.evtyp <- StormData[evclass.rowid,]$EVTYPE
evclass <- cbind(evclass.rowid, evclass.evtyp)
StormData <- StormData %>% 
        mutate(EVCLASS = replace(EVCLASS, evclass.rowid, ev.class[24,1]))

for (i in 1:N) {
        evclass.rowid <- grep(ev.class[P[i],3], StormData$EVTYPE)
        evclass.rowid <- evclass.rowid[!(evclass.rowid %in% as.integer(evclass[,1]))]
        evclass.evtyp <- StormData[evclass.rowid,]$EVTYPE
        evclass.tmp <- cbind(evclass.rowid, evclass.evtyp)
        evclass <- rbind(evclass, evclass.tmp)
        StormData <- StormData %>% 
              mutate(EVCLASS = replace(EVCLASS, evclass.rowid, ev.class[P[i],1]))
}

# 00. OTHER - weather events not classified by the regular class codes
evclass.rowid <- as.integer(row.names(StormData))
evclass.rowid <- evclass.rowid[!(evclass.rowid %in% as.integer(evclass[,1]))]
evclass.evtyp <- StormData[evclass.rowid,]$EVTYPE
evclass.tmp <- cbind(evclass.rowid, evclass.evtyp)
evclass <- rbind(evclass, evclass.tmp)
StormData <- StormData %>% 
        mutate(EVCLASS = replace(EVCLASS, evclass.rowid, ev.class[26,1]))

# subset of StormData across the USA (exclude off-shore territories).
stormsub <- StormData %>% 
        select(EV_TIMESTAMP, EVCLASS, EVTYPE, LONGITUDE, LATITUDE, STATE, COUNTY,
               FATALITIES, INJURIES, PROPDMG, PROPDMGEXP, CROPDMG, CROPDMGEXP,
               REFNUM) %>%
        filter(STATE %in% mystates & !(EVCLASS %in% c("X","Z"))) %>% 
        mutate(STATE = factor(STATE),
               EVCLASS = factor(EVCLASS, labels = ev.class[P,2]),
               PROPDMGS = mapply(udf.expont, PROPDMGEXP, PROPDMG),
               CROPDMGS = mapply(udf.expont, CROPDMGEXP, CROPDMG)) %>%
        arrange(EV_TIMESTAMP)
                # (!is.na(LONGITUDE) & !is.na(LATITUDE)) &
                #        (LONGITUDE != 0 & LATITUDE != 0)) %>%

rm(evclass.tmp, evclass.evtyp, evclass.rowid, evclass)

```


<!-- weather events frequency aggregate overview barchart plot-->
```{r data.analytic, cache=TRUE} 
pal <- mypal[seq(length(mypal), by = -2, length.out = N)]

# set up plotting layout and global graphics parameters 
par(par.def)
par(las = 1, cex.axis = 0.80, cex.lab = 0.85, ann = FALSE)
nf <- layout(matrix(c(1,2,
                      3,3,
                      4,4), nrow = 3, byrow = TRUE))

# weather events aggregate frequency by type across the USA.
evcnt1 <- stormsub %>%
        select(STATE,EVCLASS,EVTYPE,EV_TIMESTAMP) %>%
        group_by(EVCLASS) %>%
        summarise(EVCNT = n())

# plotting barchart for weather events aggregate by type across the USA.
par(mai = c(0.25,1.10,0.25,0.10))

barplot(evcnt1$EVCNT, horiz = TRUE, border = NA, col = pal, names.arg = unique(evcnt1$EVCLASS))

mtext("Weather Event Frequency Aggregate Across USA (1950 ~ 2011)", font = 2, side = 3, line = 0.25, adj = 1, cex = 0.75)
mtext("(US Affiliated Territories Not Included)", side = 3, line = -0.75, adj = 1, cex = 0.65)

maxtik <- max(axTicks(1))
m <- barplot(evcnt1$EVCNT, horiz = TRUE, plot = FALSE)
for (i in 1:length(m)) {
        j <- ifelse(evcnt1$EVCNT[i] >= maxtik, -2.25, 0.25)
        text(evcnt1$EVCNT[i], m[i], labels = formatC(evcnt1$EVCNT[i], big.mark = ","), pos = 4,  offset = j, cex = 0.70)
}

# barchart plot for weather events manifested in casualty and property/crop loss by type across the USA.
evcnt2 <- stormsub %>%
        select(EV_TIMESTAMP, STATE, EVCLASS, EVTYPE, 
               FATALITIES, INJURIES, PROPDMGS, CROPDMGS) %>%
        filter(FATALITIES > 0 | INJURIES > 0 | PROPDMGS > 0 | CROPDMGS > 0) %>%
        group_by(EVCLASS) %>%
        summarise(EVCNT = n())

# plotting barchart for aggregate frequency of weather events manifested in casualty and property/crop loss by type across the USA.
par(mai = c(0.25,0.10,0.25,1.10), yaxt = "n")

barplot(evcnt2$EVCNT, horiz = TRUE, border = NA, col = pal, names.arg = unique(evcnt2$EVCLASS))

mtext("Weather Event Frequency Aggregate Across USA (1950 ~ 2011)", font = 2, side = 3, line = 0.25, adj = 1, cex = 0.75)
mtext("Manifested in Casualty & Property/Crop Loss", font = 2, side = 3, line = -0.75, adj = 1, cex = 0.75)
mtext("(US Affiliated Territories Not Included)", side = 3, line = -1.75, adj = 1, cex = 0.65)

maxtik <- max(axTicks(1))
m <- barplot(evcnt2$EVCNT, horiz = TRUE, plot = FALSE)
for (i in 1:length(m)) {
        j <- ifelse(evcnt2$EVCNT[i] >= maxtik, -2.25, 0.25)
        text(evcnt2$EVCNT[i], m[i], labels = formatC(evcnt2$EVCNT[i], big.mark = ","), pos = 4,  offset = j, cex = 0.70)
}

# hazardous weather events in terms of casualty count and economic loss
# casualty & property/crop loss breakdown by event type of individual-state
evcnt3 <- stormsub %>%
        select(STATE, EVCLASS, EVTYPE, FATALITIES,INJURIES, PROPDMGS,CROPDMGS) %>%
        group_by(STATE, EVCLASS) %>%
        summarise(ECONLOSS = (sum(PROPDMGS) + sum(CROPDMGS)) / 1e+09,
                  CASUALTI = (sum(FATALITIES) + sum(INJURIES)) / 1e+03)

par(mai = c(0.25, 1.10, 0.25, 1.10), cex.axis = 0.75, ann = FALSE, yaxt = "s")

barplot(CASUALTI ~ EVCLASS + STATE, data = evcnt3,
        border = NA,
        col = pal)

title(ylab = "Casualty Count ( '000 )", cex.lab = 0.90)
mtext("Casualty by Event Type of Individual-State (1950 ~ 2011)", font = 2, side = 3, line = -0.75, adj = 0, padj = 0, cex = 0.75)

barplot(ECONLOSS ~ EVCLASS + STATE, data = evcnt3,
        border = NA,
        col = pal)

title(ylab = "Property/Crop Loss ( $Bn )", cex.lab = 0.90)
mtext("Property/Crop Loss by Event Type of Individual-State (1950 ~ 2011)", font = 2, side = 3, line = -0.75, adj = 1, padj = 0, cex = 0.75)

par(par.def)

```

```{r data.analytic2, cache=TRUE}
evcnt4 <- stormsub %>% 
        select(EV_TIMESTAMP, EVCLASS, 
               FATALITIES, INJURIES, PROPDMGS, CROPDMGS) %>%
        arrange(EV_TIMESTAMP) %>%
        group_by(YEARS = year(EV_TIMESTAMP), EVCLASS) %>%
        summarise(EVCNT = n(),
                  CASUALTI.mean = mean(FATALITIES + INJURIES),
                  ECONLOSS.mean = mean(PROPDMGS + CROPDMGS),
                  CASUALTI.sum = sum(FATALITIES + INJURIES),
                  ECONLOSS.sum = sum(PROPDMGS + CROPDMGS))

xyp <- xyplot(EVCNT ~ YEARS | EVCLASS, data = evcnt4,
              groups = EVCLASS,
              layout = c(2,4),
              pch = 19,
              col = pal,
              strip = FALSE,
              strip.left = TRUE,
              par.strip.text = list(cex = 0.6),
              scales = list(cex = 0.6, y = list(log = "e")),
              xlab = list(label = "Years of Observation", cex = 0.8),
              ylab = list(label = "Frequency of Weather Event (log)", cex = 0.8))

xyp <- update(xyp, panel = function(x, y, ...) {
        panel.xyplot(x, y, ...)
        panel.lmline(x, y, col = rgb(0,0,1, alpha = 0.5), lwd = 2)
        panel.abline(h = mean(y), col = rgb(1,0,0, alpha = 0.5), lwd = 2, lty = 2)
        })

print(xyp)

par(par.def)

```

```{r data.analytic3}

ev.klass <- c(1,4,5) # TORNADO, WIND.STORM & FLOOD

w <- which(year(stormsub$EV_TIMESTAMP) %in% c(2000,2010) & 
                   as.numeric(stormsub$EVCLASS) %in% ev.klass)

nf <- layout(matrix(c(1,1,1,1,2,2,
                      1,1,1,1,2,2,
                      1,1,1,1,2,2,
                      1,1,1,1,2,2,
                      1,1,1,1,3,3,
                      5,5,4,4,3,3,
                      5,5,4,4,3,3), nrow = 7, byrow = TRUE))

# Map of USA mainland
lon <- c(-130.00, -66.00)
lat <- c(25.00, 50.00)
# mymap0 <- map("world", regions = ".*usa", xlim = lon ,ylim = lat, interior = TRUE, plot = FALSE)
# plot(mymap0, type = "l", lwd = 0.5, cex.axis = 0.8, main = "USA mainland")
mymap0 <- map("state", interior = TRUE, plot = FALSE)
par(mai = c(0.25, 0.32, 0.25, 0.25))
plot(mymap0, type = "l", lwd = 0.5, ann = FALSE)
title(main = "USA mainland")
# coordinates of weather events for USA mainland
ev.w.gcs <- subset(stormsub, as.numeric(rownames(stormsub)) %in% w & 
                           ((LONGITUDE > lon[1] & LONGITUDE < lon[2]) &
                                    (LATITUDE > lat[1] & LATITUDE < lat[2])),
                   c(LONGITUDE, LATITUDE))
points(x = ev.w.gcs$LONGITUDE, y = ev.w.gcs$LATITUDE, pch = 20, cex = 0.6, 
       col = alpha(pal[ev.klass], 0.3))
legend(x = -75, y = 27, ev.class[ev.klass,2], fill = pal[ev.klass], border = pal[ev.klass], bty = "n", x.intersp = 1/2, y.intersp = 1, cex = 0.8)


# Map of Alaska
lon <- c(-180.00, -129.00)
lat <- c(50.33, 72.83)
mymap0 <- map("world", regions = ".*usa", xlim = lon ,ylim = lat, plot = FALSE)
par(mai = c(0.25, 0.32, 0.25, 0.25))
plot(mymap0, type = "l", lwd = 0.5, ann = FALSE)
title(main = "Alaska")
# coordinates of events for Alaska
ev.w.gcs <- subset(stormsub, as.numeric(rownames(stormsub)) %in% w &
                           ((LONGITUDE > lon[1] & LONGITUDE < lon[2]) &
                                    (LATITUDE > lat[1] & LATITUDE < lat[2])),
                   c(LONGITUDE, LATITUDE)
                   )
points(x = ev.w.gcs$LONGITUDE, y = ev.w.gcs$LATITUDE, pch = 20, cex = 2.0, 
       col = alpha(pal[ev.klass], 0.5))

# Map of Hawaii
lon <- c(-177.37, -153.48)
lat <- c(17.92, 29.45)
mymap0 <- map("world", regions = ".*usa", xlim = lon ,ylim = lat, plot = FALSE)
par(mai = c(0.25, 0.32, 0.25, 0.25))
plot(mymap0, type = "l", lwd = 0.5, ann = FALSE)
title(main = "Hawaii")
# coordinates of events 
ev.w.gcs <- subset(stormsub, as.numeric(rownames(stormsub)) %in% w &
                           ((LONGITUDE > lon[1] & LONGITUDE < lon[2]) &
                                    (LATITUDE > lat[1] & LATITUDE < lat[2])),
                   c(LONGITUDE, LATITUDE)
                   )
points(x = ev.w.gcs$LONGITUDE, y = ev.w.gcs$LATITUDE, pch = 20, cex = 1.2, 
       col = alpha(pal[ev.klass], 0.5))


par(mai = c(0.25, 0.82, 0.25, 0.25), ann = FALSE)

plot(log(CASUALTI.sum) ~ YEARS, 
     data = subset(evcnt4, as.numeric(EVCLASS) %in% ev.klass),
     pch = 19, col = pal[ev.klass], cex = 0.8)
title(ylab = "Number of Casualty (log scale)")
# for (i in 1:length(ev.klass)) {
#         abline(lm(CASUALTI.sum ~ YEARS,
#                   data = subset(evcnt4, as.numeric(EVCLASS) == ev.klass[i])),
#                   col = alpha(pal[i], 0.7), lwd = 2)
# }

plot(log(ECONLOSS.sum) ~ YEARS, 
     data = subset(evcnt4, as.numeric(EVCLASS) %in% ev.klass),
     pch = 19, col = pal[ev.klass], cex = 0.8)
title(ylab = "Property/Crop Loss (log scale)")
# for (i in 1:length(ev.klass)) {
#         abline(lm(ECONLOSS.sum ~ YEARS,
#                   data = subset(evcnt4, as.numeric(EVCLASS) == ev.klass[i])),
#                   col = alpha(pal[i], 0.7), lwd = 2)
# }

par(par.def)

```


```{r data.analytic.notused}
par(par.def)
par(las = 1, cex.axis = 0.50, cex.lab = 0.80, ann = FALSE)
nf <- layout(matrix(c(1,2), nrow = 2, byrow = TRUE))

# weather events aggregate frequency of individual state.
evcnt <- stormsub %>%
        select(STATE,EVCLASS,EVTYPE) %>%
        group_by(STATE, EVCLASS) %>%
        summarise(EVCNT = n()/1e+03)

# plotting barchart for the occurrence of weather-events of individual state.
par(mai = c(0.55, 1.10, 0.55, 1.10))
barplot(EVCNT ~ EVCLASS + as.character(STATE), data = evcnt, 
        horiz = FALSE, 
        border = NA,
        col = pal)
title(ylab = "Event Frequency by Type ('000)")
mtext("Weather Events Frequency Aggregate of Individual-State (1950 ~ 2011)", font = 2, side = 3, line = 0.25, adj = 0, padj = 0, cex = 0.80)

# aggregate weather events of individual state manifested in casualty and economic loss.
evcnt0 <- stormsub %>%
        select(STATE,EVCLASS,EVTYPE,FATALITIES,INJURIES,PROPDMGS,CROPDMGS) %>%
        filter(FATALITIES > 0 | INJURIES > 0 | PROPDMGS > 0 | CROPDMGS > 0) %>%
        group_by(STATE, EVCLASS) %>%
        summarise(EVCNT = n()/1e+03)

# plotting barchart for weather-events that triggered the occurrences of fatalities/injuries and properties/crops damages for each state.
par(mai = c(0.55, 1.10, 0.55, 1.10))
barplot(EVCNT ~ EVCLASS + as.character(STATE), data = evcnt0, 
        horiz = FALSE, 
        border = NA,
        col = pal)
title(ylab = "Event Frequency by Type ('000)")
mtext("Weather Events Frequency Aggregate of Individual-State (1950 ~ 2011)", font = 2, side = 3, line = 0.25, adj = 0, padj = 0, cex = 0.75)
mtext("Manifested in Casualty & Property/Crop Loss", font = 2, side = 3, line = -0.75, adj = 0, padj = 0, cex = 0.75)


# nf <- layout(matrix(c(1,2,
#                       1,3), nrow = 2, byrow = TRUE))
# par(mai = c(0.41,0.82,0.41,0.42))
# plot(EVCNT ~ YEARS, data = evcnt4, 
#      pch = 19,
#      col = pal,
#      log = "y"
#      )
# for (i in 1:N) {
#         abline(lm(EVCNT ~ YEARS, evcnt4, subset = EVCLASS), col = pal[i])
# }
# plot(CASUALTI ~ YEARS, data = evcnt4, 
#      pch = 19,
#      col = pal,
#      log = "y"
#      )
# for (i in 1:N) {
#         abline(lm(CASUALTI ~ YEARS, evcnt4, as.numeric(EVCLASS) == i), col = pal[i])
# }
# plot(ECONLOSS ~ YEARS, data = evcnt4, 
#      pch = 19,
#      col = pal,
#      log = "y"
#      )
# for (i in 1:N) {
#         abline(lm(ECONLOSS ~ YEARS, evcnt4, as.numeric(EVCLASS) == i), col = pal[i])
# }
# par(par.def)


# # save an archive copy of StormData data.table to local `r datadir`
# for (i in 1:length(filenam)) {
#         fileout <- paste(datadir, filenam[i], sep = "/")
#         fileout <- paste(fileout, "csv", "bz2", sep = ".")
#         filesrc <- bzfile(fileout, open = "w")
#         write.csv(get(filenam[i]), filesrc, row.names = FALSE)
#         flush(filesrc)
# }
# close(filesrc)
# rm(fileout)
# 
# read StormData from saved archive copy data file on local disk
# filesrc <- paste(datadir, "StormData.csv.bz2", sep = "/")
# filesrc <- bzfile(filesrc, open = "r") # establish a connection to local file
# StormData <- data.table(read.csv(filesrc, skip = 0))
# flush(filesrc)
# close(filesrc)

```


