---
title: "Reproducible Research - Peer Assessment2"
author: "robertwcw"
date: "9/21/2020"
output: 
  html_document: 
    fig_caption: yes
    keep_md: yes
---
## SYNOPSIS

Natural disaster triggered by storms and abnormal weather phenomenons may lead to public health issues and dire economic consequences. The extent, severity, and impact of injuries/fatalities and economic losses are largely determined by the amount of energy unleashed by the types of events in the weather related disasters. This data analysis attempts to address the concerns **WHERE** the events took place and **WHEN** the disasters struck by **WHAT** types of events give rise to deleterious social impact aftermath with respect to economic and public health. Base on the US National Oceanic and Atmospheric Administration (NOAA) storm database, this project makes use of relevant metrics of the number of human injuries/fatalities, financial losses in properties/crops damages in relation to events types across the US from year 1950 to year 2011.  
&nbsp;

#### Set up R workspace environment
```{r setup, message=TRUE, echo=FALSE, resuts="hide"}
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(TZ = "UTC")      # set global TZ to UTC for POSIXt class

.Rfliburl <- "https://raw.githubusercontent.com/robertwcw/Rflib/master"
source(file.path(.Rfliburl,"getRflib.R"),local = TRUE)
source(getRflib("is.defined.R"),local = TRUE)
source(getRflib("strCap.R"),local = TRUE)
# source(getRflib("myplclust.R"),local = TRUE)

library(data.table)
# library(lubridate)
library(dplyr)
library(maps)
# library(xts)

# 'udf.num2gcs' user-defined function to convert LATITUDE & LONGITUDE coordinate values in integer type to nnn.dddd geographic coordinate system format 
udf.num2gcs <- function(X, y) { # y is number of significant digits.
        if (!is.na(X) & !is.null(X) & is.numeric(X)) {
                x <- as.character(X)
                l <- nchar(x)
                ifelse(l < 3, return(as.numeric(x)),
                       ifelse(l == 3, y <- 1,
                              ifelse(l == 4, y <- 2,
                                     ifelse(l > 4, y <- y, y <- 0))))
                y <- l - y
                X <- as.numeric(paste0(x,"e",-y))
        }
        return(X)
}

# 'udf.stripsign' user-defined function to strip -ve sign from numeric value
udf.stripsign <- function(x) {
        if (!is.na(x) & !is.null(x) & is.numeric(x)) {
                x <- x * sign(x)
        }
        return(x)
}

# 'udf.prependsign' user-defined function to prepend -ve sign to numeric value
udf.prependsign <- function(x) {
        if (!is.na(x) & !is.null(x) & is.numeric(x)) {
                x <- x * sign(-x)
        }
        return(x)
}

# 'udf.str2time' user-defined function to put TIME string into proper format
udf.str2time <- function(x) {
        l <- nchar(x)
        x <- case_when(
                l %in% c(3,4) ~ {
                        z <- substr(strptime(sprintf("%04s", x), "%H%M"), 12, 19)
                        ifelse(is.na(z) | z == "", 
                               "00:00:00",
                               substr(strptime(sprintf("%04s", x), "%H%M"), 12, 19))
                },
                l == 11 ~ {
                        z <- substr(strptime(x, "%I:%M:%S %p"), 12, 19)
                        ifelse(is.na(z),
                               substr(strptime(x, "%H:%M:%S"), 12, 19),
                               ifelse(z == "",
                                      substr(strptime(x, "%H:%M:%S %p"), 12, 19),
                                      z))
                },
                TRUE ~ x
        )
        return(x) 
}
```
&nbsp;

#### Data Loading

Loading *raw* comma-delimited text file data set downloaded from course website into R workspace as data.table class object with naming of the data object derives from website data source programmatically, by-passing manual data staging as much as possible during loading phase.

```{r data.load, cache=TRUE, echo=FALSE, resuts="hide"}
# loading data downloaded from course website into R workspace 

# set data source url to course website
fileurl <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
datadir <- paste(".", "data", sep = "/")
filetmp <- tempfile()
filenam <- character()

download.file(fileurl, filetmp)

if (!dir.exists(datadir)) {
        dir.create(datadir)
}

# extract source data file name as name of work data object in workspace 
filels <- strsplit(basename(fileurl), "%2F", fixed = TRUE)[[1]]
for (i in 1:length(filels)) {
        filein <- strsplit(filels[i], ".", fixed = TRUE)[[1]]
        if (length(filein) > 1) {
                filenam[i] <- filein[1]
                filesrc <- bzfile(filetmp, open = "r")
                assign(filenam[i], data.table(read.csv(filesrc)))
                flush(filesrc)
        }
}
close(filesrc)

filenam <- filenam[which(!is.na(filenam))]

# # save an archive copy of StormData data.table to local `r datadir`
# for (i in 1:length(filenam)) {
#         fileout <- paste(datadir, filenam[i], sep = "/")
#         fileout <- paste(fileout, "csv", "bz2", sep = ".")
#         filesrc <- bzfile(fileout, open = "w")
#         write.csv(get(filenam[i]), filesrc, row.names = FALSE)
#         flush(filesrc)
# }
# close(filesrc)
# rm(fileout)

unlink(filetmp)
rm(fileurl,filetmp,filesrc,filels,filein)
```
&nbsp;

#### Exploratory Data Analysis

```{r eda.0}
for (i in 1:length(filenam)) {
        print(paste(i, ":",filenam[i], "(",floor(object.size(get(filenam[i]))/10e+05),"MB)"))
}
rm(i)
```
**`r length(filenam)`** *raw* data `r ifelse(length(filenam) > 1, "sets were", "set was")` loaded into R workspace from NOAA sourced data downloaded from the course website. (number in bracket depicts memory footprint).

Structure of data object **`r filenam[1]`**.
```{r eda.1}
str(get(filenam[1]))
```
**`r length(names(get(filenam[1])))`** columns found in the *raw* data set **`r filenam[1]`**. 

<!-- For this data analysis work, we shall create a working data set called **stormdata** consisting 18 data columns grabbed from the *raw* data set **`r filenam[1]`**. (see attached list) -->

```{r data.proc, results = "hide"}
# column number of the selected variable
v <- c(1,2,3,4,5,6,7,8,12,13,19,20,21,22,23,24,25,26,27,28,32,33,34,35,37)
names(get(filenam[1]))[v]


# HYPOTHESIS: an event began on BGN_DATE at BGN_TIME in one county and is said to end on END_DATE equates BGN_DATE at END_TIME in same county when END_DATE is empty but END_TIME is not. {END_DATE == "" & END_TIME != ""} 

# HYPOTHESIS: an event began on BGN_DATE at BGN_TIME in one county and is said to be ended on END_DATE at END_TIME equates 23:59:59 (postulated) in same county when END_DATE is not empty but END_TIME contains empty value, though the event may continued on to neighbouring county. {END_DATE != "" & END_TIME == ""} 

# HYPOTHESIS: {END_DATE == "" & END_TIME == ""} an event began on BGN_DATE at BGN_TIME in one county and is said to be ended in same county on END_DATE equates BGN_DATE at END_TIME equates 23:59:59 when END_DATE and END_TIME both contain empty values, though the event may continued on to neighbouring county at the cut-over time at 00:00:00 next-day.

# HYPOTHESIS: an event began on BGN_DATE at BGN_TIME in one county and is said to be ended in the same county on END_DATE at END_TIME. {END_DATE != "" & END_TIME != ""} 


#    user  system elapsed 
# 571.131  96.633 667.883 
d1 <- sub(" .*", "", StormData$BGN_DATE)
d2 <- gsub("[oO]", "0", StormData$BGN_TIME) # rectify typo error of 'O' for '0'
d2 <- sub("12:00:00 AM", "00:00:00", d2) # rectify non-POSIXt compliant time fmt
d2 <- sub("00:00:00 AM", "00:00:00", d2) # rectify non-POSIXt compliant time fmt
d2 <- unlist(lapply(d2, udf.str2time)) # unify various time format to "hh:mm:ss"

StormData <- StormData %>% mutate(EV_TIMESTAMP = as.POSIXct(strptime(paste(d1,d2), "%m/%d/%Y %H:%M:%S")))

rm(d1,d2)

# # # NOT USED
# # prepend -ve sign to LONGITUDE values belong to the western hemisphere
#   StormData$LONGITUDE <- sapply(StormData$LONGITUDE, udf.prependsign)

# reformat LATITUDE vector to geographic coordinate system format nnn.ddd
  numsign <- sign(StormData$LATITUDE)
  lat <- sapply(StormData$LATITUDE, udf.stripsign)
  lat <- sapply(lat, udf.num2gcs, 2) # param '2' is number of significant digits
  StormData$LATITUDE <- lat * (numsign * numsign) # LATs belong to northern hemisphere 

#    user  system elapsed 
# 39.976   0.271  40.281 
# reformat LONGITUDE vector to geographic coordinate system format nnn.ddd
  numsign <- sign(StormData$LONGITUDE)
  lon <- sapply(StormData$LONGITUDE, udf.stripsign)
  lon <- sapply(lon, udf.num2gcs, 3) # param '3' is number of significant digits
  StormData$LONGITUDE <- lon * (numsign * -numsign) # LONs belong to western hemisphere

rm(lon, lat, numsign)  

StormData$EVTYPE <- toupper(StormData$EVTYPE)
StormData$EVTYPE <- gsub("[\\]", " ", StormData$EVTYPE)
StormData$EVTYPE <- gsub("[\\/]", " ", StormData$EVTYPE)
StormData$EVTYPE <- gsub("[A-Z]\\- [A-Z]|[A-Z] \\-[A-Z]|[A-Z]\\-[A-Z]", " - ", StormData$EVTYPE)
StormData$EVTYPE <- gsub("WATERSPOUT-", "WATERSPOUT", StormData$EVTYPE)
StormData$EVTYPE <- gsub("WIND\\.|WINDS\\.", "WIND", StormData$EVTYPE)
StormData$EVTYPE <- gsub("ING.", "ING ", StormData$EVTYPE)
repeat {
        StormData$EVTYPE <- gsub("  ", " ", StormData$EVTYPE)
        if (length(grep("  ", StormData$EVTYPE)) == 0) {break}
}
StormData$EVTYPE <- trimws(StormData$EVTYPE)
StormData$EVTYPE <- factor(x = StormData$EVTYPE)

StormData$STATE <- toupper(trimws(StormData$STATE))
StormData$STATE <- factor(x = StormData$STATE) 

```

```{r data.analytic, warnings=FALSE}
par.def <- par() # make a copy of default graphic parameters.

# all states of the USA (exclude off-shore territories).
states <- c(unique(state.fips$abb), "AK", "HI") 

# set up colour palette.
set.seed(9)
N <- sample.int(502, 251)
N <- sample(N, 40)
pal <- colors(TRUE)[N]

# subset of StormData across the USA (exclude off-shore territories).
stormsub <- StormData %>% 
        select(EV_TIMESTAMP,EVTYPE,LONGITUDE,LATITUDE,STATE,COUNTY,
               FATALITIES,INJURIES,PROPDMG,PROPDMGEXP,CROPDMG,CROPDMGEXP) %>%
        filter(as.character(STATE) %in% states & 
                (!is.na(LONGITUDE) & !is.na(LATITUDE)) & 
                       (LONGITUDE != 0 & LATITUDE != 0)) %>%
        arrange(EV_TIMESTAMP)
stormsub$EVTYPE <- as.character(stormsub$EVTYPE)
stormsub$EVTYPE <- sub("WATERSPOUT", "WS", stormsub$EVTYPE)
stormsub$EVTYPE <- sub("TORNADO(ES| F0| F1| F3)", "TORNADO", stormsub$EVTYPE)
stormsub$EVTYPE <- sub("THUNDERSTORM", "TSTM", stormsub$EVTYPE)
stormsub$EVTYPE <- as.factor(stormsub$EVTYPE)

# aggregate of weather events that triggered the occurrences of fatalities/injuries and properties/crops damages aggregated across the USA.
evcnt <- stormsub %>%
        select(STATE, EVTYPE, FATALITIES, INJURIES, PROPDMG, CROPDMG) %>%
        filter(FATALITIES > 0 | INJURIES > 0 | PROPDMG > 0 | CROPDMG > 0) %>%
        group_by(EVTYPE) %>%
        count(EVTYPE) 

evty.pal <- cbind(matrix(evcnt$EVTYPE),
                  pal[seq(length(pal), by = -1, length.out = length(evcnt$EVTYPE))])
pal <- pal[seq(length(pal), by = -1, length.out = length(evcnt$EVTYPE))]

# evcnt <- evcnt %>% mutate(typal = evty.pal[which(evty.pal[,1] == EVTYPE),2])

# set up global graphics parameters for the plots
par(mfrow = c(2,1), ann = FALSE)

# plotting barchart for weather events that triggered the occurrences of fatalities/injuries and properties/crops damages aggregated across the USA.
par(mai = c(0.25,1.20,0.50,1.20), las = 1, cex.axis = 0.65)
barplot(evcnt$n, horiz = TRUE, border = NA, col = pal, names.arg = unique(evcnt$EVTYPE))
m <- barplot(evcnt$n, horiz = TRUE, plot = FALSE)
for (i in 1:length(m)) {text(1, m[i], evcnt$n[i], pos = 4, cex = 0.60)}
mtext("Aggregate Frequency of Events Observed across The USA (1950 ~ 2011)", side = 1, line = -2, adj = 1, cex = 0.65)

# aggregate of weather events that triggered the occurrences of fatalities/injuries and properties/crops damages for individual state.
evcnt <- stormsub %>%
        select(STATE, EVTYPE, FATALITIES, INJURIES, PROPDMG, CROPDMG) %>%
        filter(FATALITIES > 0 | INJURIES > 0 | PROPDMG > 0 | CROPDMG > 0) %>%
        group_by(EVTYPE, STATE) %>%
        count(EVTYPE, STATE) 

# evcnt <- evcnt %>% mutate(typal = evty.pal[which(evty.pal[,1] == EVTYPE),2])

# plotting barchart for weather-events that triggered the occurrences of fatalities/injuries and properties/crops damages for individual state.
par(mai = c(1.00,1.20,0.25,1.20), cex.axis = 0.6, cex.lab = 0.65, ann = TRUE)
barplot(n ~ EVTYPE + as.character(STATE), data = evcnt, 
        horiz = FALSE, 
        border = NA,
        col = pal,
        ylab = "Type Aggregate",
        xlab = "States")

suppressWarnings(par(par.def))

# title(main = "Aggregate Weather Events of USA (1950 ~ 2011)", outer = TRUE)
```

```{r house.keeping}
# detach("package:xts", unload = TRUE)
detach("package:dplyr", unload = TRUE)
detach("package:data.table", unload = TRUE)
```
